#  设计一个高可用的redis缓存

####  什么数据作为缓存，什么时候失效，什么时候更新，先更新缓存还是先更新数据库

- 什么数据缓存：频繁查询的，修改少的数据，比如：什么排名，热点

- 以什么类型存放到redis中：转成JSON字符串

- 用什么做为key：以模块作为#前缀+id（流水号） 

- 修改的时候更新，删除的时候删除

- 对于先更新缓存还是先更新数据库，这个都会有数据不一致的问题

  具体的看业务，要求强一致性的，可以通过加分布式锁来更新

  一致性要求不高，对性能要求高的可以通过更新数据前后都删除缓存。

  在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。这样最差的情况是在超时时间内存在不一致，当然这种情况极其少见，可能的原因就是服务宕机。此种情况可以满足绝大多数需求。 当然这种策略要考虑redis和数据库主从同步的耗时，所以在第二次删除前最好休眠一定时间，比如500毫秒，这样毫无疑问又增加了写请求的耗时

  再者可以通过读取binlong的方法，异步淘汰缓存。

- 过期时间设置多久？

  这个也是要分析具体的业务，慢慢去调整到最优的方案，我们项目设置的过期时间是一天。

####   如何解决缓存雪崩的问题

​	缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到数据库，最终导致数据库瞬时压力过大而崩溃。

​	例如我们有 1000 个KEY，而每个 KEY 的并发请求不大，只有 10 次。而缓存雪崩指的就是这 1000 个 KEY 在同一时间，同时失效，这个时候就突然有 1000 ** 10 = 一万次查询。

缓存雪崩导致的问题一般很难排查，如果没有事先预防，很可能要花很大力气才能找得到原因。对于缓存雪崩的情况，**最简单的方案就是在原有失效时间的基础上增加一个随机时间（例如1-5分钟）**，这样每个缓存过期时间的重复率就会降低，从而减少缓存雪崩的发生。

####  如何解决缓存穿透的问题

​	缓存穿透是指查询一个一定不存在的数据，因为这个数据不存在，所以永远不会被缓存，所以每次请求都会去请求数据库。

例如我们请求一个 UserID 为 -1 的用户数据，因为该用户不存在，所以该请求每次都会去读取数据库。在这种情况下，如果某些心怀不轨的人利用这个存在的漏洞去伪造大量的请求，那么很可能导致DB承受不了那么大的流量就挂掉了。

​	这种穿透问题，我们事前做参数校验，比如UserId为负数的拒绝请求，这个方法没有办法做到全面的参数校验的，无法根本解决这个问题。

​	然后就是做事后预防，对于查到的空的数据也需要缓存一个空数据，设置一个较短的时间。比如一分钟

####  缓存击穿

​	如果你的应用中有一些访问量很高的热点数据，我们一般会将其放在缓存中以提高访问速度。另外，为了保持时效性，我们通常还会设置一个过期时间。但是对于这些访问量很高的KEY，我们需要考虑一个问题：当热点KEY在失效的瞬间，海量的请求会不会产生大量的数据库请求，从而导致数据库崩溃？

​	在低可用，高一致性的业务场景下可以加分布式锁，每次更新数据库，更新缓存只有一个线程可以进入，防止大量请求到数据，但是这个有个确定就是大量请求阻塞在内存中，虚拟机是否可以抗的住。

​	从缓存的角度来看，如果你设置了永远不过期，那么就不会有海量请求数据库的情形出现。此时我们一般通过新起一个线程的方式去**定时将数据库中的数据更新到缓存中**，更加成熟的方式是通过**定时任务去同步缓存和数据库的数据。**

但这种方案会出现数据的延迟问题，也就是线程读取到的数据并不是最新的数据。但对于一般的互联网功能来说，些许的延迟还是能接受的。

